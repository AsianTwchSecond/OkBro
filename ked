local runservice = game:GetService("RunService")
local camera = workspace.CurrentCamera
local players = game:GetService("Players")
local replicatedStorage = game:GetService("ReplicatedStorage")
local localplayer = players.LocalPlayer
local inputservice = game:GetService("UserInputService")
local mouse = localplayer:GetMouse()
local SoundService = game:GetService("SoundService")
local Stats = game:GetService("Stats")
local Player = game:GetService("Players").LocalPlayer

-- // FIX UI (REQUIRED)
getgenv().triggerbot = getgenv().triggerbot or {
    Enabled = false,
    TriggerCooldown = 0.01,
    BlacklistedTools = {},
}

--=============================================
--  BLACK CHAMS ENGINE (Self / Accessories / Tools)
--  Step 1 to Step 5 (FULL SYSTEM)
--=============================================

getgenv().CharmStates = {
    Self = false,
    Accessories = false,
    Tools = false
}

local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Black = Color3.fromRGB(0, 0, 0)

local OriginalProps = {}     -- stores original material + color
local CharmConnections = {}  -- stores signals for cleanup


--=============================================
--  STEP 2 - Save & Restore
--=============================================

local function SavePart(part)
    if not OriginalProps[part] then
        OriginalProps[part] = {
            Material = part.Material,
            Color = part.Color
        }
    end
end

local function RestorePart(part)
    local data = OriginalProps[part]
    if data then
        part.Material = data.Material
        part.Color = data.Color
        OriginalProps[part] = nil
    end
end


--=============================================
--  STEP 3 - Individual Charm Functions
--=============================================

-- SELF CHARM
local function ApplySelfCharm(Char)
    for _, v in ipairs(Char:GetDescendants()) do
        if v:IsA("BasePart") and v.Parent:IsA("Model") then
            SavePart(v)
            v.Material = Enum.Material.ForceField
            v.Color = Black
        end
    end
end

local function RemoveSelfCharm(Char)
    for _, v in ipairs(Char:GetDescendants()) do
        if v:IsA("BasePart") and v.Parent:IsA("Model") then
            RestorePart(v)
        end
    end
end


-- ACCESSORIES CHARM
local function ApplyAccCharm(Char)
    for _, acc in ipairs(Char:GetChildren()) do
        if acc:IsA("Accessory") and acc:FindFirstChild("Handle") then
            SavePart(acc.Handle)
            acc.Handle.Material = Enum.Material.ForceField
            acc.Handle.Color = Black
        end
    end
end

local function RemoveAccCharm(Char)
    for _, acc in ipairs(Char:GetChildren()) do
        if acc:IsA("Accessory") and acc:FindFirstChild("Handle") then
            RestorePart(acc.Handle)
        end
    end
end


-- TOOL CHARM
local function ApplyToolCharm(Char)
    for _, tool in ipairs(Char:GetChildren()) do
        if tool:IsA("Tool") then
            for _, v in ipairs(tool:GetDescendants()) do
                if v:IsA("BasePart") then
                    SavePart(v)
                    v.Material = Enum.Material.ForceField
                    v.Color = Black
                end
            end
        end
    end
end

local function RemoveToolCharm(Char)
    for _, tool in ipairs(Char:GetChildren()) do
        if tool:IsA("Tool") then
            for _, v in ipairs(tool:GetDescendants()) do
                if v:IsA("BasePart") then
                    RestorePart(v)
                end
            end
        end
    end
end


--=============================================
--  STEP 4 - Update Chams (Master Controller)
--=============================================

local function UpdateChams()
    local Char = Player.Character
    if not Char then return end

    -- SELF
    if CharmStates.Self then
        ApplySelfCharm(Char)
    else
        RemoveSelfCharm(Char)
    end

    -- ACCESSORIES
    if CharmStates.Accessories then
        ApplyAccCharm(Char)
    else
        RemoveAccCharm(Char)
    end

    -- TOOLS
    if CharmStates.Tools then
        ApplyToolCharm(Char)
    else
        RemoveToolCharm(Char)
    end
end


--=============================================
--  STEP 5 - Respawn & Tool Handling
--=============================================

Player.CharacterAdded:Connect(function(Char)
    task.wait(0.3)
    UpdateChams()

    local c = Char.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            task.wait(0.1)
            UpdateChams()
        end
    end)

    table.insert(CharmConnections, c)
end)

getgenv().stile = {
    hitbox_expander = {
        Enabled = false,
        Size = 15,
        Transparency = 0.5,
        Color = Color3.fromRGB(255, 0, 0),
    },

    Visuals = {
        Self = {
            Enabled = false,
            Color = Color3.fromRGB(255, 255, 255),
        }
    }
}

ESPSettings = {
    Enabled = true,

    Box = {
        Enabled = true,
        Thickness = 1,
        Color = Color3.fromRGB(255, 0, 0),
        OutlineColor = Color3.fromRGB(0, 0, 0),
        UseOutline = true
    },

    Tracer = {
        Enabled = true,
        Thickness = 1,
        Color = Color3.fromRGB(255, 255, 0),
        OutlineColor = Color3.fromRGB(0, 0, 0),
        From = "Bottom",
        FollowMouse = false,
        UseOutline = true
    },

    NameTag = {
        Enabled = true,
        Color = Color3.fromRGB(255, 255, 255),
        OutlineColor = Color3.fromRGB(0, 0, 0)
    },

    Distance = {
        Enabled = true,
        Color = Color3.fromRGB(200, 200, 200),
        OutlineColor = Color3.fromRGB(0, 0, 0)
    },

    HealthBar = {
        Enabled = true,
        OutlineColor = Color3.fromRGB(0, 0, 0)
    },

    Highlight = {
        Enabled = true,
        FillColor = Color3.fromRGB(255, 255, 255),
        OutlineColor = Color3.fromRGB(255, 0, 0),
        Transparency = 0.5
    },

    TeamCheck = true
}

local MacroEnabled = false
local EmoteEnabled = false
local EmoteID = "15610015346" -- YungBlud Emote

local repo = 'https://raw.githubusercontent.com/deividcomsono/Obsidian/main/'

local library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local thememanager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local savemanager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
Library:SetWatermarkVisibility(true)

Library:SetWatermarkVisibility(true)

local FrameTimer = tick()
local FrameCounter = 0
local FPS = 60

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter += 1

    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end

    local currentTime = os.date("%H:%M:%S")

    Library:SetWatermark(('Eclipse.lol| %s fps | %s ms | Time: %s'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue()),
        currentTime
    ))
end)

local ToggleGui = Instance.new("ScreenGui")
ToggleGui.Name = "UIToggle"
ToggleGui.ResetOnSpawn = false
ToggleGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ToggleGui.Parent = game.CoreGui

local ToggleButton = Instance.new("ImageButton")
ToggleButton.Size = UDim2.new(0, 70, 0, 50)
ToggleButton.Position = UDim2.new(1, -1100, 0, 100)
ToggleButton.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
ToggleButton.BackgroundTransparency = 1
ToggleButton.Image = "rbxassetid://109014824057194"
ToggleButton.Parent = ToggleGui

Instance.new("UICorner", ToggleButton).CornerRadius = UDim.new(0, 10)

local isVisible = true
ToggleButton.MouseButton1Click:Connect(function()
    if library and library.Toggle then
        library:Toggle()
        isVisible = not isVisible
        -- same image both states as you chose Option 1
        ToggleButton.Image = "rbxassetid://109014824057194"
    end
end)

local game_name = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name

local Hooks = {}

getgenv().Divine = {
  Settings = {
    Smoothness = 0.1,
  },

  Camlock = {
    enabled = true,
    resolver = false,
    Prediction = 0.1,
    HitPart = "HumanoidRootPart",
    target = nil
  },

  Targetaim = {
    enabled = true,
    target = nil,
    predictionEnabled = true,
    Prediction = 0.1,
    HitPart = "HumanoidRootPart",
    Method = "Namecall"
  },

  AutoAir = {
     enabled = true,
     jumpOffset = 0.8,
     delay = 0.1,
     AirPart = "RightFoot"
  }
}

getgenv().crosshair = {
    enabled = false,
    refreshrate = 0,
    mode = "center",
    position = Vector2.new(0, 0),
    width = 1.5,
    length = 10,
    radius = 11,
    color = Color3.fromRGB(255, 255, 255),
    spin = true,
    spin_speed = 120,
    spin_max = 200,
    spin_style = Enum.EasingStyle.Circular,
    resize = true,
    resize_speed = 150,
    resize_min = 5,
    resize_max = 22
}

local Window = library:CreateWindow({
    Title = 'Eclipse',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2,
    Footer = "1.0.0 Eclipse REWRITE",
    Size = UDim2.fromOffset(620, 500),
    Icon = "71218955901149"
})

local Options = library.Options

local Tabs = {
    combat = Window:AddTab("Combat", "crosshair"),
	 raging = Window:AddTab("Rage", "eye"),
    visuals = Window:AddTab("Miscellaneous ", "wrench"),
    Settings = Window:AddTab("Settings", "settings")
}


local Divine = getgenv().Divine

game.Players.LocalPlayer.CharacterAdded:Connect(function()
    Divine.Camlock.target = nil
    Divine.Targetaim.target = nil
end)

local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")
local SoundService = game:GetService("SoundService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Camera = workspace.CurrentCamera

local function FindNearestEnemy()
  local closest = nil
	local shortestDist = math.huge
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
			local pos = plr.Character.HumanoidRootPart.Position
			local screenPos, onScreen = Camera:WorldToViewportPoint(pos)
			if onScreen then
				local dist = (Vector2.new(screenPos.X, screenPos.Y) - Camera.ViewportSize / 2).Magnitude
				if dist < shortestDist then
					shortestDist = dist
					closest = plr
				end
			end
		end
	end
	return closest
end

local ScreenGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local TextButton = Instance.new("ImageButton")
local UICorner = Instance.new("UICorner")

local CoreGui = game:GetService("CoreGui")
ScreenGui.Parent = CoreGui
ScreenGui.ResetOnSpawn = false
ScreenGui.Enabled = true

Frame.Parent = ScreenGui
Frame.BackgroundTransparency = 1
Frame.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame.Size = UDim2.new(0, 90, 0, 90)
Frame.Active = true

TextButton.Parent = Frame
TextButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
TextButton.BackgroundTransparency = 0.5
TextButton.Size = UDim2.new(0, 75, 0, 75)
TextButton.AnchorPoint = Vector2.new(0.5, 0.5)
TextButton.Position = UDim2.new(0.5, 0, 0.5, 0)
TextButton.Image = "rbxassetid://129225087302154"
TextButton.Active = true

TextButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = TextButton.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

TextButton.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        TextButton.Position = UDim2.new(
            startPos.X.Scale, startPos.X.Offset + delta.X,
            startPos.Y.Scale, startPos.Y.Offset + delta.Y
        )
    end
end)

UICorner.Parent = TextButton
UICorner.CornerRadius = UDim.new(0, 12)

TextButton.MouseButton1Click:Connect(function()
    -- toggle state
    getgenv().Divine.Camlock.enabled = not getgenv().Divine.Camlock.enabled

    if getgenv().Divine.Camlock.enabled then
        -- try to lock on someone
        local enemy = FindNearestEnemy()
        if enemy then

            -- ENABLE BOTH SYSTEMS
            getgenv().Divine.Camlock.enabled = true
            getgenv().Divine.Targetaim.enabled = true

            -- SET TARGET FOR BOTH
            getgenv().Divine.Camlock.target = enemy
            getgenv().Divine.Targetaim.target = enemy

            -- UI
            TextButton.Image = "rbxassetid://138552945575395"
            library:Notify("EC: Enabled, Target: " .. enemy.DisplayName, 2)

        else
            -- NO TARGET FOUND -> TURN OFF
            getgenv().Divine.Camlock.enabled = false
            getgenv().Divine.Targetaim.enabled = false
            getgenv().Divine.Camlock.target = nil
            getgenv().Divine.Targetaim.target = nil

            TextButton.Image = "rbxassetid://129225087302154"
            library:Notify("No Target Found", 2)
        end

    else
        -- BUTTON TURNED OFF -> DISABLE BOTH
        getgenv().Divine.Camlock.enabled = false
        getgenv().Divine.Targetaim.enabled = false

        getgenv().Divine.Camlock.target = nil
        getgenv().Divine.Targetaim.target = nil

        TextButton.Image = "rbxassetid://129225087302154"
        library:Notify("EC Off", 2)
    end
end)

local UserInputService = game:GetService("UserInputService")

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end

    -------------------------------
    --  F KEY (Keyboard Toggle)
    -------------------------------
    if input.KeyCode == Enum.KeyCode.F then
        
        getgenv().Divine.Camlock.enabled = not getgenv().Divine.Camlock.enabled

        if getgenv().Divine.Camlock.enabled then
            local enemy = FindNearestEnemy()
            if enemy then
                getgenv().Divine.Camlock.target = enemy
                getgenv().Divine.Targetaim.target = enemy
                TextButton.Image = "rbxassetid://71218955901149"
                library:Notify("EC: Enabled (F), Target: " .. enemy.DisplayName, 2)
            end
        else
            getgenv().Divine.Camlock.enabled = false
getgenv().Divine.Targetaim.enabled = false

getgenv().Divine.Camlock.target = nil
getgenv().Divine.Targetaim.target = nil
            TextButton.Image = "rbxassetid://71218955901149"
            library:Notify("EC: Disabled (F)", 2)
        end
    end


    -------------------------------
    --  CONTROLLER BUTTON Y
    -------------------------------
    if input.KeyCode == Enum.KeyCode.ButtonY then
        
        getgenv().Divine.Camlock.enabled = not getgenv().Divine.Camlock.enabled

        if getgenv().Divine.Camlock.enabled then
            local enemy = FindNearestEnemy()
            if enemy then
                getgenv().Divine.Camlock.target = enemy
                getgenv().Divine.Targetaim.target = enemy
                TextButton.Image = "rbxassetid://71218955901149"
                library:Notify("EC: Enabled (Y), Target: " .. enemy.DisplayName, 2)
            end
        else
            getgenv().Divine.Camlock.enabled = false
getgenv().Divine.Targetaim.enabled = false

getgenv().Divine.Camlock.target = nil
getgenv().Divine.Targetaim.target = nil
            TextButton.Image = "rbxassetid://71218955901149"
            library:Notify("EC: Disabled (Y)", 2)
        end
    end
end)

RunService.Heartbeat:Connect(function()
    if Divine.Camlock.enabled then
        local camTarget = Divine.Camlock.target
        if camTarget and camTarget.Character then
            local camPart = camTarget.Character:FindFirstChild(Divine.Camlock.HitPart)
       if camPart then
    local camPredicted = camPart.Position
        + (camPart.Velocity * Divine.Camlock.Prediction)
        + Vector3.new(0, Divine.AutoAir.jumpOffset, 0)

                local camGoal = CFrame.new(Camera.CFrame.Position, camPredicted)
                Camera.CFrame = Camera.CFrame:Lerp(camGoal, Divine.Settings.Smoothness)
            end
        end
    end

    if Divine.AutoAir.enabled then
        local Victim = Divine.Targetaim.target
        if Victim and Victim.Character then
            local TargetRootPart = Victim.Character:FindFirstChild(Divine.AutoAir.AirPart)
            if TargetRootPart then
                local TargetVel = TargetRootPart.Velocity
                if TargetVel.Y > 25 then
                    local Character = LocalPlayer.Character
                    if Character then
                        local Tool = Character:FindFirstChildOfClass("Tool")
                        if Tool then
                            task.wait(Divine.AutoAir.delay)
                            Tool:Activate()
                        end
                    end
                end
            end
        end
    end
end)

if not Divine.Camlock.enabled and Divine.AutoAir.enabled then return end

if Divine.Targetaim.Method == "Namecall" then
    local __namecall
    __namecall = hookmetamethod(game, "__namecall", newcclosure(function(Self, ...)
        local Args = {...}
        local Method = tostring(getnamecallmethod())
        if not checkcaller() and Method == "FireServer" then
            for i, Arg in pairs(Args) do
           if typeof(Arg) == "Vector3" and Divine.Targetaim.enabled then
    local Target = Divine.Targetaim.target
    if Target and Target.Character and Divine.Targetaim.HitPart and Target.Character[Divine.Targetaim.HitPart] then
        local TargetPart = Target.Character[Divine.Targetaim.HitPart]

        local predictedPosition = TargetPart.Position
            + (TargetPart.Velocity * Divine.Targetaim.Prediction)
            + Vector3.new(0, Divine.AutoAir.jumpOffset, 0)

        Args[i] = predictedPosition
    end
    return __namecall(Self, unpack(Args))
end

local function setup_hooks()
    local function TargetFuturePosition()
        if not target or not target.Character then
            return nil
        end
        local target_part = target.Character[Divine.Targetaim.HitPart]
        if not target_part then
            return nil
        end

        local position = target_part.Position
        if Divine.Targetaim.predictionEnabled then
            position = position + (target_part.Velocity * Divine.Targetaim.Prediction) local Yoffset = 0

-- Psalm logic (Up = JumpOffset, Down = FallOffset)
if TargetPart.Velocity.Y > 1 then
    Yoffset = Divine.AutoAir.jumpOffset
elseif TargetPart.Velocity.Y < -1 then
    Yoffset = 0
end

Args[i] = predictedPosition + Vector3.new(0, Yoffset, 0)
        end
        return position
    end

    Hooks[1] =
        hookmetamethod(
        mouse,
        "__index",
        newcclosure(
            function(self, index)
                if
                    index == "Hit" and locking and (Divine.Targetaim.Method == "Index") and
                        target and
                        target.Character and
                        target.Character:FindFirstChild(Divine.Targetaim.HitPart)
                 then
                    local futurePos = TargetFuturePosition()
                    if futurePos then
                        return CFrame.new(futurePos)
                    end
                end
                return Hooks[1](self, index)
            end
        )
    )
end

if not Divine.Targetaim.enabled then return end

local function onHeartbeat()
    if not getgenv().Divine.Camlock.resolver then return end

    for _, Target in pairs(Players:GetPlayers()) do
        if Target ~= LocalPlayer and Target.Character then
            local Character = Target.Character
            local Humanoid = Character:FindFirstChildOfClass("Humanoid")

            if Humanoid and Humanoid.MoveDirection.Magnitude > 0 then
                local moveVelocity = Humanoid.MoveDirection * 16

                local TargetParts = {
                    "HumanoidRootPart",
                    "UpperTorso",
                    "LowerTorso",
                    "LeftUpperLeg",
                    "LeftLowerLeg",
                    "RightUpperLeg",
                    "RightLowerLeg",
                    "Head",
                    "LeftHand",
                    "RightHand"
                }

                for _, partName in ipairs(TargetParts) do
                    local Part = Character:FindFirstChild(partName)
                    if Part then
                        Part.Velocity = moveVelocity
                        Part.AssemblyLinearVelocity = moveVelocity
                    end
                end
            end
        end
    end
end

RunService.Heartbeat:Connect(onHeartbeat)

getgenv().cframe = getgenv().cframe or {}
local cframe = getgenv().cframe

cframe.settings = {
    enabled = true,
    showbutton = true,
    speed = 1
}

local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")

if cframe.settings.showbutton then
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "SpeedCFrameGUI"
    ScreenGui.ResetOnSpawn = false
    ScreenGui.Parent = game.CoreGui

    local Button = Instance.new("TextButton")
    Button.Name = "SpeedCFrameButton"
    Button.Size = UDim2.new(0, 80, 0, 60)
    Button.Position = UDim2.new(0.55, -955, 0.57, -355)
    Button.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Button.BackgroundTransparency = 0.1
    Button.Text = cframe.settings.enabled and "CF: ON" or "CF: OFF"
    Button.TextColor3 = Color3.fromRGB(255, 255, 255)
    Button.Font = Enum.Font.Code
    Button.TextSize = 18
    Button.Parent = ScreenGui

    local Outline = Instance.new("UIStroke")
    Outline.Color = Color3.fromRGB(250, 250, 250)
    Outline.Thickness = 1
    Outline.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    Outline.Parent = Button

    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 10)
    UICorner.Parent = Button

    Button.MouseButton1Click:Connect(function()
        cframe.settings.enabled = not cframe.settings.enabled
        Button.Text = cframe.settings.enabled and "CF: ON" or "CF: OFF"
    end)

    -- Dragging support
    local dragging = false
    local startPos, startMousePos

    Button.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            startPos = Button.Position
            startMousePos = input.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    Button.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - startMousePos
            Button.Position = UDim2.new(
                startPos.X.Scale, startPos.X.Offset + delta.X,
                startPos.Y.Scale, startPos.Y.Offset + delta.Y
            )
        end
    end)
end

if not getgenv().cframe.settings.showbutton then return end

RunService.Heartbeat:Connect(function()
    if cframe.settings.enabled and LocalPlayer.Character then
        local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if root and humanoid then
            local move_dir = humanoid.MoveDirection
            root.CFrame = root.CFrame + (move_dir * cframe.settings.speed)
        end
    end
end)

--// AUTO PREDICTION (DaStrike Blatant)

local function getPing()
    return game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
end

local autoPredictionRunning = false

local function startAutoPrediction()
    if autoPredictionRunning then return end
    autoPredictionRunning = true

    task.spawn(function()
        while autoPredictionRunning do

            local ping = getPing()
            local pred

            if ping <= 40 then
                pred = 0.1458912       -- 40ms Blatant
            elseif ping <= 50 then
                pred = 0.1403592       -- 50ms Blatant
            elseif ping <= 60 then
                pred = 0.1213536       -- 60ms Blatant
            elseif ping <= 70 then
                pred = 0.1355798        -- 70ms Blatant
            elseif ping <= 80 then
                pred = 0.1226346       -- 80ms Blatant
            elseif ping <= 90 then
                pred = 0.1400822       -- 90ms Blatant
            elseif ping <= 100 then
                pred = 0.1436029425      -- 100ms Blatant
            elseif ping <= 120 then
                pred = 0.1155657825
            elseif ping <= 140 then
                pred = 0.1491826658
            else
                pred = 0.1404715572
            end

           getgenv().Divine.Targetaim.Prediction = pred
getgenv().Divine.Camlock.Prediction = pred

            task.wait(1)
        end
    end)
end

local function stopAutoPrediction()
    autoPredictionRunning = false
end
local function stopAutoPrediction()
	autoPredictionRunning = false
end

getgenv().exlareCircle = getgenv().exlareCircle or {
	enabled = false,
	color = Color3.fromRGB(255, 255, 255),
	radius = 100,
	circle = nil
}

if not getgenv().exlareCircle.circle then
	getgenv().exlareCircle.circle = Drawing.new("Circle")
	getgenv().exlareCircle.circle.Filled = false
	getgenv().exlareCircle.circle.Thickness = 1
end

function updateexlareCircle()
	if getgenv().exlareCircle.circle then
		getgenv().exlareCircle.circle.Visible = getgenv().exlareCircle.enabled
		getgenv().exlareCircle.circle.Color = getgenv().exlareCircle.color
		getgenv().exlareCircle.circle.Radius = getgenv().exlareCircle.radius
		getgenv().exlareCircle.circle.Position = Vector2.new(
			workspace.CurrentCamera.ViewportSize.X / 2,
			workspace.CurrentCamera.ViewportSize.Y / 2
		)
	end
end

game:GetService("RunService").RenderStepped:Connect(function()
	if getgenv().exlareCircle.enabled and getgenv().exlareCircle.circle then
		getgenv().exlareCircle.circle.Position = Vector2.new(
			workspace.CurrentCamera.ViewportSize.X / 2,
			workspace.CurrentCamera.ViewportSize.Y / 2
		)
	end
end)

local old
old =
    hookfunction(
    Drawing.new,
    function(class, properties)
        local drawing = old(class)
        for i, v in next, properties or {} do
            drawing[i] = v
        end
        return drawing
    end
)

local function solve(angle, radius)
    return Vector2.new(math.sin(math.rad(angle)) * radius, math.cos(math.rad(angle)) * radius)
end

local last_render = 0
local drawings = {
    crosshair = {},
    text = {
        Drawing.new("Text", {Size = 13, Font = 2, Outline = true, Text = "Eclipse", Color = Color3.new(1, 1, 1)}),
        Drawing.new("Text", {Size = 13, Font = 2, Outline = true, Text = " .lol", Color = Color3.new(0.5, 0.5, 0.5)})
    }
}

for idx = 1, 4 do
    drawings.crosshair[idx] = Drawing.new("Line")
    drawings.crosshair[idx + 4] = Drawing.new("Line")
end

local box = Drawing.new("Square")
box.Visible = false
box.Color = Color3.new(1, 1, 1)
box.Thickness = 1
box.Filled = false

local tracer = Drawing.new("Line")
tracer.Visible = false
tracer.Color = Color3.new(1, 1, 1)
tracer.Thickness = 1

getgenv().exlare = getgenv().exlare or {}
getgenv().exlare.esp = {
	box = false,
	tracer = false
}

RunService.RenderStepped:Connect(function()
	local target = getgenv().Divine and getgenv().Divine.Targetaim and getgenv().Divine.Targetaim.target

	if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") and target.Character:FindFirstChild("Head") then
		local hrp = target.Character.HumanoidRootPart
		local head = target.Character.Head

		local hrpPos, hrpOnScreen = Camera:WorldToViewportPoint(hrp.Position)
		local headPos, headOnScreen = Camera:WorldToViewportPoint(head.Position)

		local screenHeight = math.abs(hrpPos.Y - headPos.Y) * 2
		local boxSize = Vector2.new(screenHeight / 1.5, screenHeight)

		if getgenv().exlare.esp.box and hrpOnScreen then
			box.Size = boxSize
			box.Position = Vector2.new(hrpPos.X - boxSize.X / 2, hrpPos.Y - boxSize.Y / 2)
			box.Visible = true
		else
			box.Visible = false
		end

		if getgenv().exlare.esp.tracer and hrpOnScreen then
			tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
			tracer.To = Vector2.new(hrpPos.X, hrpPos.Y)
			tracer.Visible = true
		else
			tracer.Visible = false
		end
	else
		box.Visible = false
		tracer.Visible = false
	end
end)

getgenv().hit = {
    detection = true,
    logs = true,
    notify_duration = 1,
    sound_enabled = true,
    sound_id = "Neverlose",
    sound_volume = 1
}

local HitSoundId = {
    Bameware = "rbxassetid://3124331820",
    Neverlose = "rbxassetid://6534948092",
    Bell = "rbxassetid://6534947240",
    Bubble = "rbxassetid://6534947588",
    Pick = "rbxassetid://1347140027",
    Pop = "rbxassetid://198598793",
    Rust = "rbxassetid://1255040462",
    Sans = "rbxassetid://3188795283",
    Fart = "rbxassetid://130833677",
    Big = "rbxassetid://5332005053",
    Vine = "rbxassetid://5332680810",
    Bruh = "rbxassetid://4578740568",
    Skeet = "rbxassetid://5633695679",
    Fatality = "rbxassetid://6534947869",
    Bonk = "rbxassetid://5766898159",
    Minecraft = "rbxassetid://4018616850"
}

local hitSoundsNames = {"Bameware", "Neverlose", "Bubble", "Pick", "Pop", "Rust", "Sans", "Fart", "Big", "Vine", "Bruh", "Skeet", "Fatality", "Bonk","Minecraft"}

local last_health = {}

RunService.PostSimulation:Connect(function()
    local Divine = getgenv().Divine
    if not Divine then return end

    local target = Divine.Targetaim and Divine.Targetaim.target
    local locking = Divine.Camlock and Divine.Camlock.enabled
    local humanoid = target and target.Character and target.Character:FindFirstChild("Humanoid")

    if locking and target and humanoid and hit.detection then
        local current_health = humanoid.Health

        if not last_health[target.UserId] then
            last_health[target.UserId] = current_health
        end

        if current_health < last_health[target.UserId] then
            if hit.sound_enabled and HitSoundId[hit.sound_id] then
                local sound = Instance.new("Sound")
                sound.SoundId = HitSoundId[hit.sound_id]
                sound.Volume = hit.sound_volume
                sound.Parent = workspace
                sound:Play()
                game:GetService("Debris"):AddItem(sound, 2)
            end

            if hit.logs and library then
                library:Notify("Hit: " .. target.DisplayName, hit.notify_duration)
            end
        end

        last_health[target.UserId] = current_health
    end
end)

getgenv().orbit = {
	enabled = false,
	distance = 10,
	height = 5,
	speed = 400,
	angle = 0
}

game:GetService("RunService").Heartbeat:Connect(function(dt)
	if not getgenv().orbit.enabled then return end

	local lp = game.Players.LocalPlayer
	if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then return end

	local target = getgenv().Divine and getgenv().Divine.Camlock and getgenv().Divine.Camlock.target
	if not target or not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then return end

	local root = lp.Character.HumanoidRootPart
	local targetRoot = target.Character.HumanoidRootPart

	getgenv().orbit.angle += dt * getgenv().orbit.speed
	local angleRad = math.rad(getgenv().orbit.angle)

	local offset = Vector3.new(
		math.cos(angleRad) * getgenv().orbit.distance,
		getgenv().orbit.height,
		math.sin(angleRad) * getgenv().orbit.distance
	)

	local orbitPosition = targetRoot.Position + offset
	root.CFrame = CFrame.new(orbitPosition, targetRoot.Position)
end)

getgenv().Divine.Visualize = getgenv().Divine.Visualize or {enabled = false}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- ⭐ DOT ONLY
local dot = Drawing.new("Circle")
dot.Color = Color3.fromRGB(255, 255, 255)
dot.Thickness = 2
dot.Filled = true
dot.Radius = 4
dot.Visible = false

RunService.RenderStepped:Connect(function()
    if not getgenv().Divine.Visualize.enabled then
        dot.Visible = false
        return
    end

    local target = getgenv().Divine.Targetaim and getgenv().Divine.Targetaim.target
    if target and target.Character then
        local hrp = target.Character:FindFirstChild("HumanoidRootPart")

        if hrp then
            -- ⭐ NORMAL HEAD OFFSET (same as old system)
            local pos, onScreen = Camera:WorldToViewportPoint(
                hrp.Position + Vector3.new(0, 1.5, 0)
            )

            if onScreen then
                dot.Visible = true
                dot.Position = Vector2.new(pos.X, pos.Y)
            else
                dot.Visible = false
            end
        else
            dot.Visible = false
        end
    else
        dot.Visible = false
    end
end)

getgenv().AntiAimViewer = {
    enabled = false,
}

local China = setmetatable({}, {
    __index = function(_, service)
        return game:GetService(service)
    end
})

local Players = China.Players
local ReplicatedStorage = China.ReplicatedStorage
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local MainEvent = ReplicatedStorage:FindFirstChild("MainEvent")

local function Bypass(Entity)
    Entity.ChildAdded:Connect(function(Child)
        if Child:IsA("Tool") then
            Child.Activated:Connect(function()
                if MainEvent then
                    MainEvent:FireServer("UpdateMousePos", Mouse.Hit.Position)
                end
            end)
        end
    end)
end

local function Alive(Player)
    return Player and Player.Character and Player.Character:FindFirstChild("Humanoid") and Player.Character:FindFirstChild("Head")
end

LocalPlayer.CharacterAdded:Connect(function(Character)
    Bypass(Character)
end)

if getgenv().AntiAimViewer then
    if Alive(LocalPlayer) then
        LocalPlayer.Character.Humanoid:UnequipTools()
        Bypass(LocalPlayer.Character)
    end
end

local Hook
Hook = hookmetamethod(game, "__namecall", function(self, ...)
    local Args = {...}
    local Method = getnamecallmethod()

    if not checkcaller() and Method == "FireServer" and self.Name == "MainEvent" and Args[1] == "UpdateMousePos" then
        if getgenv().AntiAimViewer then
            Args[2] = Mouse.Hit.Position
        end
        return self.FireServer(self, unpack(Args))
    end

    return Hook(self, ...)
end)

getgenv().EnemyStats = {
    Enabled = false,
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local ScreenGui
local Frame, PFPImage, NameLabel, HealthFill

local function createGUI()
    if ScreenGui then return end

    ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Parent = game.CoreGui

    Frame = Instance.new("Frame")
    Frame.Size = UDim2.new(0, 250, 0, 100)
    Frame.AnchorPoint = Vector2.new(0.5, 0.5)
    Frame.Position = UDim2.new(0.5, 0, 0.85, 0)
    Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Frame.BorderSizePixel = 2
    Frame.BorderColor3 = Color3.fromRGB(255, 255, 255)
    Frame.Parent = ScreenGui

    PFPImage = Instance.new("ImageLabel")
    PFPImage.Size = UDim2.new(0, 80, 0, 80)
    PFPImage.Position = UDim2.new(0, 10, 0, 10)
    PFPImage.BackgroundTransparency = 1
    PFPImage.Parent = Frame

    NameLabel = Instance.new("TextLabel")
    NameLabel.Size = UDim2.new(0, 140, 0, 30)
    NameLabel.Position = UDim2.new(0, 100, 0, 10)
    NameLabel.BackgroundTransparency = 1
    NameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    NameLabel.TextScaled = true
    NameLabel.Font = Enum.Font.GothamBold
    NameLabel.Text = ""
    NameLabel.Parent = Frame

    local HealthBack = Instance.new("Frame")
    HealthBack.Size = UDim2.new(0, 140, 0, 15)
    HealthBack.Position = UDim2.new(0, 100, 0, 50)
    HealthBack.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    HealthBack.BorderSizePixel = 1
    HealthBack.BorderColor3 = Color3.fromRGB(255, 255, 255)
    HealthBack.Parent = Frame

    HealthFill = Instance.new("Frame")
    HealthFill.Size = UDim2.new(1, 0, 1, 0)
    HealthFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    HealthFill.BorderSizePixel = 0
    HealthFill.Parent = HealthBack
end

local function destroyGUI()
    if ScreenGui then
        ScreenGui:Destroy()
        ScreenGui = nil
        Frame, PFPImage, NameLabel, HealthFill = nil
    end
end

RunService.RenderStepped:Connect(function()
    local camEnabled = getgenv().Divine.Camlock.enabled
    local target = getgenv().Divine.Targetaim.target

    if getgenv().EnemyStats.Enabled and camEnabled and target then
        if not ScreenGui then createGUI() end

        local player = target
        if player and player.UserId then
            local thumb, isReady = Players:GetUserThumbnailAsync(player.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420)
            if isReady then
                PFPImage.Image = thumb
            end
            NameLabel.Text = player.DisplayName or player.Name
        end

        local char = player.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.MaxHealth > 0 then
            local hpPercent = humanoid.Health / humanoid.MaxHealth
            HealthFill.Size = UDim2.new(math.clamp(hpPercent, 0, 1), 0, 1, 0)
            HealthFill.BackgroundColor3 = Color3.fromRGB(255 - (hpPercent * 255), hpPercent * 255, 0)
        end
    else
        destroyGUI()
    end
end)

getgenv().GroundShotDetection = {
    Enabled = false,
    GroundShotThreshold = 0.5,
    DetectionRange = 20
}

local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local function isGroundShot(hitPosition)
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end

    local feetPosition = rootPart.Position - Vector3.new(0, humanoid.HipHeight, 0)
    local distanceToFeet = (hitPosition - feetPosition).Magnitude
    return distanceToFeet <= getgenv().GroundShotDetection.GroundShotThreshold
end

local function onCharacterAdded(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
end

localPlayer.CharacterAdded:Connect(onCharacterAdded)

workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
    workspace.CurrentCamera.ChildAdded:Connect(function(child)
        if getgenv().GroundShotDetection.Enabled then
            if child:IsA("BasePart") and child.Name == "Bullet" then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart and (child.Position - rootPart.Position).Magnitude <= getgenv().GroundShotDetection.DetectionRange then
                    if isGroundShot(child.Position) then
                    end
                end
            end
        end
    end)
end)

getgenv().charactermod = {
    enabled = true,
    speed = 27,
    jump = 50,
    fov = 70,
    _dev = {},
}

local main = Tabs.combat:AddLeftGroupbox('Main Settings')
local air = Tabs.combat:AddRightGroupbox('Air Settings')
local ag = Tabs.combat:AddRightGroupbox('Anti ground shots')
local speed = Tabs.combat:AddRightGroupbox('CFrame')
local hit_group = Tabs.visuals:AddLeftGroupbox('Hit Sounds')
local circleBox = Tabs.visuals:AddLeftGroupbox('Visuals')
local imp = Tabs.visuals:AddRightGroupbox('important')
local blatant = Tabs.visuals:AddRightGroupbox('Blatant')
local hvh = Tabs.raging:AddLeftGroupbox('HVH Orbit')
local ant = Tabs.visuals:AddRightGroupbox('Antilocks')
local charm = Tabs.visuals:AddRightGroupbox('Charms') 
local at = Tabs.raging:AddRightGroupbox('Autos')

getgenv().AutoReloadEnabled = false

local function autoReload()
    while getgenv().AutoReloadEnabled do
        task.wait(0.1)

        local character = game.Players.LocalPlayer.Character
        if character then
            local tool = character:FindFirstChildWhichIsA("Tool")
            if tool then
                local ammo = tool:FindFirstChild("AMMO")
                local reloadEvent = tool:FindFirstChildWhichIsA("RemoteEvent")

                if ammo and reloadEvent and ammo.Value == 0 then
                    reloadEvent:FireServer()
                    task.wait(1)
                end
            end
        end
    end
end

at:AddToggle('autoReloadToggle', {
    Text = 'Enable auto reload',
    Default = false,
    Callback = function(state)
        getgenv().AutoReloadEnabled = state
        if state then
            task.spawn(autoReload)
        end
    end
})

at:AddButton(
    'Auto Shoot',
    function()
        local ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Parent = game.CoreGui

        local button = Instance.new("TextButton")
        button.Size = UDim2.new(0, 80, 0, 60)
        button.Position = UDim2.new(0.5, -100, 0.5, -25)
        button.Text = "Auto Shoot"
        button.BackgroundColor3 = Color3.new(0, 0, 0)
        button.BackgroundTransparency = 0.3
        button.TextColor3 = Color3.new(1, 1, 1)
        button.Font = Enum.Font.Code
        button.TextWrapped = true
        button.TextScaled = true
        button.Parent = ScreenGui
        button.Draggable = true
        button.Active = true
        button.Selectable = true

        local Outline = Instance.new("UIStroke")
        Outline.Color = Color3.fromRGB(250, 250, 250)
        Outline.Thickness = 1
        Outline.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        Outline.Parent = button

        local UICorner = Instance.new("UICorner")
        UICorner.Parent = button

        local autoShooting = false

        local function autoShoot()
            while autoShooting do
                local character = game.Players.LocalPlayer.Character
                if character then
                    local tool = character:FindFirstChildOfClass("Tool")
                    if tool and tool:FindFirstChild("Handle") then
                        tool:Activate()
                    end
                end
                task.wait()
            end
        end

        button.MouseButton1Click:Connect(
            function()
                autoShooting = not autoShooting
                button.Text = autoShooting and "Auto On" or "Auto Off"

                if autoShooting then
                    task.spawn(autoShoot)
                end
            end
        )
    end
)

getgenv().antilock = {
    enabled = false,
    mode = "Sky" -- or predbreaker
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

RunService.Heartbeat:Connect(function()
    local player = Players.LocalPlayer
    local character = player.Character

    if character and character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = character.HumanoidRootPart
        local vel = humanoidRootPart.Velocity

        if getgenv().antilock.enabled then
            if getgenv().antilock.mode == "Predbreaker" then
                humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
            elseif getgenv().antilock.mode == "Sky" then
                humanoidRootPart.Velocity = Vector3.new(0, 100, 0)
            end
        end

        RunService.RenderStepped:Wait()
        humanoidRootPart.Velocity = vel
    end
end)

ant:AddToggle(
    'Toggle antilock',
    {
        Text = 'Enable Anti Lock',
        Default = false,
        Tooltip = 'Toggle Anti Lock system',
        Callback = function(state)
            getgenv().antilock.enabled = state
        end
    }
)

ant:AddDropdown(
    'Antilockmode',
    {
        Values = {'Sky', 'Predbreaker'},
        Default = getgenv().antilock.mode,
        Multi = false,
        Text = 'Anti Lock Mode',
        Tooltip = 'Select Anti Lock mode',
        Callback = function(value)
            getgenv().antilock.mode = value
        end
    }
)

hvh:AddToggle('orbit', {
   Text =  'Enable Orbit',
   Default = getgenv().orbit.enabled,
   Callback = function(value) getgenv().orbit.enabled = value end
})

hvh:AddInput('ortbitz', {
   Text = 'Orbit Speed',
   Default = getgenv().orbit.speed,
   Callback = function(value) getgenv().orbit.speed = tonumber(value) or 400 end
})

hvh:AddInput('orbitz', {
   Text = 'Orbit Height',
   Default = getgenv().orbit.height,
   Callback = function(value) getgenv().orbit.height = tonumber(value) or 5 end
})

hvh:AddInput('oree', {
   Text = 'Orbit Distance',
   Default = getgenv().orbit.distance,
   Callback = function(value) getgenv().orbit.distance = tonumber(value) or 10 end
})

main:AddToggle('enable_cam', {
    Text = 'Enable Camlock',
    Default = getgenv().Divine.Camlock.enabled,
    Callback = function(state)
        getgenv().Divine.Camlock.enabled = state
        if state and not getgenv().Divine.Camlock.target then
            local enemy = FindNearestEnemy()
            if enemy then
                getgenv().Divine.Camlock.target = enemy
            end
        end
    end
})

main:AddToggle('enable', {
    Text = 'Enable TargetAim',
    Default = getgenv().Divine.Targetaim.enabled,
    Callback = function(state)
    getgenv().Divine.Targetaim.enabled = state
    if state and not getgenv().Divine.Targetaim.target then
        local enemy = FindNearestEnemy()
        if enemy then
            getgenv().Divine.Targetaim.target = enemy
        end
    end
end
})

main:AddToggle("TrigToggle", {
    Text = "Enable Triggerbot",
    Default = false,
    Callback = function(val)
        getgenv().triggerbot.Enabled = val
        print("Triggerbot:", val)
    end
})

main:AddSlider("CooldownSlide", {
    Text = "Trigger Cooldown",
    Default = 0.01,
    Min = 0,
    Max = 0.2,
    Rounding = 3,
    Compact = false,
    Callback = function(val)
        getgenv().triggerbot.TriggerCooldown = val
    end
})

main:AddToggle("visualize_enemy", {
    Text = "Visualize",
    Default = getgenv().Divine.Visualize.enabled,
    Callback = function(val)
        getgenv().Divine.Visualize.enabled = val
    end
})

main:AddToggle("stats_enemy", {
    Text = "Enemy Stats",
    Default = getgenv().EnemyStats.Enabled,
    Callback = function(val)
        getgenv().EnemyStats.Enabled = val
    end
})

main:AddToggle('enable_aav', {
    Text = 'Enable AntiAimViewer',
    Default = false,
    Callback = function(value) getgenv().AntiAimViewer = value end
})

main:AddToggle("AutoPrediction", {
	Text = "Auto Prediction",
	Default = false,
	Callback = function(state)
		if state then
			startAutoPrediction()
		else
			stopAutoPrediction()
		end
	end
})

main:AddToggle('resolver', {
    Text = 'Resolver',
    Default = Divine.Camlock.resolver,
    Callback = function(value) Divine.Camlock.resolver = value end
})

main:AddDropdown('method', {
    Text = 'Hook Method',
    Values = {'Namecall', 'Index'},
    Default = getgenv().Divine.Targetaim.Method,
    Callback = function(value)
         getgenv().Divine.Targetaim.Method = value:lower()
    end
})

main:AddDropdown('hitpart', {
    Text = 'Hit Part',
    Values = {'HumanoidRootPart', 'UpperTorso', 'LowerTorso', 'Head'},
    Default = getgenv().Divine.Targetaim.HitPart,
    Callback = function(value)
        getgenv().Divine.Targetaim.HitPart = value
        getgenv().Divine.Camlock.HitPart = value
    end
})

main:AddInput('Prediction', {
    Text = 'Prediction',
    Default = getgenv().Divine.Targetaim.Prediction,
    Callback = function(val)
        local num = tonumber(val) or 0.1
        getgenv().Divine.Targetaim.Prediction = num
        getgenv().Divine.Camlock.Prediction = num
    end
})

main:AddInput('smoothness', {
    Text = 'Smoothness',
    Default = getgenv().Divine.Settings.Smoothness,
    Callback = function(val)
        getgenv().Divine.Settings.Smoothness = tonumber(val) or 0.1
    end
})

main:AddToggle("HitboxToggle", {
    Text = "Enable Hitbox Expander",
    Default = getgenv().stile.hitbox_expander.Enabled,
    Callback = function(state)
        getgenv().stile.hitbox_expander.Enabled = state
        _G.Disabled = not state
    end
})

main:AddInput("HitboxSizeInput", {
    Text = "Hitbox Size",
    Default = tostring(getgenv().stile.hitbox_expander.Size),
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local size = tonumber(value)
        if size then
            getgenv().stile.hitbox_expander.Size = size
            
            print("Hitbox size set to:", size)
        end
    end
})

main:AddToggle("SelfChamsToggle", {
    Text = "Enable Self Chams",
    Default = getgenv().stile.Visuals.Self.Enabled,
    Callback = function(state)
        getgenv().stile.Visuals.Self.Enabled = state
        print("Self Chams:", state)
    end
})

circleBox:AddToggle("circle_enabled", {
	Text = "Enable FOV",
	Default = getgenv().exlareCircle.enabled,
	Callback = function(state)
		getgenv().exlareCircle.enabled = state
		updateexlareCircle()
	end
})

circleBox:AddInput("circle_radius", {
	Text = "FOV Radius",
	Default = tostring(getgenv().exlareCircle.radius),
	Numeric = true,
	Finished = true,
	Callback = function(val)
		local number = tonumber(val)
		if number then
			getgenv().exlareCircle.radius = number
			updateexlareCircle()
		end
	end
})

circleBox:AddToggle("crosshair_enabled", {
	Text = "Enable Crosshair",
	Default = getgenv().crosshair.enabled,
	Callback = function(state)
		getgenv().crosshair.enabled = state
	end
})

circleBox:AddDropdown('Crosshair_Type', {
    Values = {'Center', 'Mouse'},
    Default = 'Center',
    Text = 'Crosshair Mode',
    Callback = function(value)
        getgenv().crosshair.mode = value:lower()
    end
})

circleBox:AddInput("crosshair_radius", {
	Text = "Crosshair Radius",
	Default = tostring(getgenv().crosshair.radius),
	Numeric = true,
	Finished = true,
	Callback = function(val)
		local num = tonumber(val)
		if num then
			getgenv().crosshair.radius = num
		end
	end
})

--// SPINBOT SETUP
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local SpinEnabled = false
local SpinSpeed = 15

--// SPINBOT LOOP
RunService.RenderStepped:Connect(function()
    if SpinEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local root = LocalPlayer.Character.HumanoidRootPart
        root.CFrame = root.CFrame * CFrame.Angles(0, math.rad(SpinSpeed), 0)
    end
end)

--// UI ELEMENTS
circleBox:AddToggle("SpinbotToggle", {
    Text = "Enable Spinbot",
    Default = false,
    Tooltip = "Toggle character spin",
}):OnChanged(function(value)
    SpinEnabled = value
end)

circleBox:AddSlider("SpinSpeedSlider", {
    Text = "Spin Speed",
    Default = 15,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Compact = false,
}):OnChanged(function(value)
    SpinSpeed = value
end)

circleBox:AddToggle("esp_box", {
	Text = "Target Box",
	Default = getgenv().exlare.esp.box,
	Callback = function(state)
		getgenv().exlare.esp.box = state
	end
})

circleBox:AddToggle("esp_tracer", {
	Text = "Target Tracer",
	Default = getgenv().exlare.esp.tracer,
	Callback = function(state)
		getgenv().exlare.esp.tracer = state
	end
})

blatant:AddButton("Load WalkSpeed", function()
    if getgenv().Loaded_Extra then
        library:Notify("Already Loaded!", 2)
        return
    end

    getgenv().Loaded_Extra = true

    loadstring(game:HttpGet("https://pastebin.com/raw/nabv9FbK"))()
    library:Notify("Loaded Successfully!", 2)
end)

blatant:AddButton("Load JumpPower", function()
    if getgenv().Loaded_Extras then
        library:Notify("Already Loaded!", 2)
        return
    end

    getgenv().Loaded_Extras = true

    loadstring(game:HttpGet("https://pastebin.com/raw/N2QRSEUt"))()
    library:Notify("Loaded Successfully!", 2)
end)

--// ESP UI (Linoria)
local ESPGroup = Tabs.visuals:AddLeftGroupbox("ESP")

ESPGroup:AddToggle("ESPEnabled", {
    Text = "Enable ESP",
    Default = ESPSettings.Enabled
}):OnChanged(function(v)
    ESPSettings.Enabled = v
end)

ESPGroup:AddToggle("BoxESP", {
    Text = "Box",
    Default = ESPSettings.Box.Enabled
}):OnChanged(function(v)
    ESPSettings.Box.Enabled = v
end)

ESPGroup:AddToggle("TracerESP", {
    Text = "Tracer",
    Default = ESPSettings.Tracer.Enabled
}):OnChanged(function(v)
    ESPSettings.Tracer.Enabled = v
end)

ESPGroup:AddDropdown("TracerOrigin", {
    Text = "Tracer Origin",
    Values = {"Bottom", "Middle", "Mouse"},
    Default = ESPSettings.Tracer.From
}):OnChanged(function(v)
    ESPSettings.Tracer.From = v
end)

ESPGroup:AddToggle("TracerFollowMouse", {
    Text = "Tracer Follow Mouse",
    Default = ESPSettings.Tracer.FollowMouse
}):OnChanged(function(v)
    ESPSettings.Tracer.FollowMouse = v
end)

ESPGroup:AddToggle("NameTagESP", {
    Text = "Name Tag",
    Default = ESPSettings.NameTag.Enabled
}):OnChanged(function(v)
    ESPSettings.NameTag.Enabled = v
end)

ESPGroup:AddToggle("DistanceESP", {
    Text = "Distance Text",
    Default = ESPSettings.Distance.Enabled
}):OnChanged(function(v)
    ESPSettings.Distance.Enabled = v
end)

ESPGroup:AddToggle("HealthESP", {
    Text = "Health Bar",
    Default = ESPSettings.HealthBar.Enabled
}):OnChanged(function(v)
    ESPSettings.HealthBar.Enabled = v
end)

ESPGroup:AddToggle("HighlightESP", {
    Text = "Highlight",
    Default = ESPSettings.Highlight.Enabled
}):OnChanged(function(v)
    ESPSettings.Highlight.Enabled = v
end)

ESPGroup:AddToggle("TeamCheckESP", {
    Text = "Team Check",
    Default = ESPSettings.TeamCheck
}):OnChanged(function(v)
    ESPSettings.TeamCheck = v
end)

ESPGroup:AddToggle("ambient_toggle", {
    Text = "Ambient",
    Default = false,
    Callback = function(state)
        local Lighting = game:GetService("Lighting")

        if state then
            -- ENABLE AMBIENT
            Lighting.Ambient = Color3.fromRGB(120, 120, 255)
            Lighting.OutdoorAmbient = Color3.fromRGB(120, 120, 255)
            Lighting.EnvironmentDiffuseScale = 1
            Lighting.EnvironmentSpecularScale = 1
        else
            -- DISABLE / RESET AMBIENT
            Lighting.Ambient = Color3.fromRGB(127, 127, 127)
            Lighting.OutdoorAmbient = Color3.fromRGB(127, 127, 127)
            Lighting.EnvironmentDiffuseScale = 0
            Lighting.EnvironmentSpecularScale = 0
        end
    end
})

charm:AddToggle('SelfCharm', {
    Text = 'Self Charm',
    Default = false,
    Callback = function(v)
        CharmStates.Self = v
        UpdateChams()
    end
})

charm:AddToggle('AccCharm', {
    Text = 'Accessories Charm',
    Default = false,
    Callback = function(v)
        CharmStates.Accessories = v
        UpdateChams()
    end
})

charm:AddToggle('ToolCharm', {
    Text = 'Tool Charm',
    Default = false,
    Callback = function(v)
        CharmStates.Tools = v
        UpdateChams()
    end
})

hit_group:AddToggle('detection', {
    Text = 'Hit Detection',
    Default = hit.detection,
    Callback = function(value) hit.detection = value end
})

hit_group:AddToggle('logs', {
    Text = 'Hit Logs',
    Default = hit.logs,
    Callback = function(value) hit.logs = value end
})

hit_group:AddToggle('sound_enabled', {
    Text = 'Hit Sound',
    Default = hit.sound_enabled,
    Callback = function(value) hit.sound_enabled = value end
})

hit_group:AddInput('notify_duration', {
    Default = hit.notify_duration,
    Text = 'Notify Duration',
    Numeric = true,
    Finished = true,
    Callback = function(value)
        hit.notify_duration = tonumber(value) or 1
    end
})

hit_group:AddDropdown('sounds', {
    Values = hitSoundsNames,
    Default = hit.sound_id,
    Text = 'Hit Sound',
    Callback = function(value)
        hit.sound_id = value
    end
})

hit_group:AddInput('sound_volume', {
    Default = hit.sound_volume,
    Text = 'Sound Volume',
    Numeric = true,
    Finished = true,
    Callback = function(value)
        hit.sound_volume = tonumber(value) or 1
    end
})

imp:AddToggle("FOVToggle", {
    Text = "Enable Custom FOV",
    Default = false,
    Callback = function(state)
        FOVEnabled = state
    end
})

-- // Slider
imp:AddSlider("FOVSlider", {
    Text = "FOV Amount",
    Default = 120,
    Min = 70,
    Max = 120,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        FOVValue = value
    end
})

-- // Force FOV Loop
task.spawn(function()
    while task.wait() do
        if FOVEnabled then
            Camera.FieldOfView = FOVValue
        end
    end
end)

imp:AddButton('Rejoin Same Server', function()
    local TeleportService = game:GetService("TeleportService")
    local Players = game:GetService("Players")
    local localPlayer = Players.LocalPlayer

    TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, localPlayer)
end)

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local displayName = player.DisplayName

local function getGreeting()
    local hour = os.date("*t").hour
    if hour < 12 then
        return "Good Morning"
    elseif hour < 18 then
        return "Good Afternoon"
    else
        return "Good Evening"
    end
end

local function startGreetingUpdater(label)
    task.spawn(function()
        while true do
            label:SetText(getGreeting() .. ", " .. displayName .. "!")
            task.wait(30) -- check every 30 seconds
        end
    end)
end

-- Load Macro Button
imp:AddButton("Load Macro", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/CookieScript/Trace.Iol/refs/heads/main/Macro", true))()
end)

-- Adjust Speed Slider
imp:AddSlider("MacroSpeed", {
    Text = "Adjust Speed",
    Default = 1,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        _G.MacroSpeed = Value
    end
})

-- Set default speed variable
_G.MacroSpeed = 1

local greetingLabel = main:AddLabel("...") -- placeholder
startGreetingUpdater(greetingLabel)

air:AddToggle('enabled', {
    Text = 'Auto Air',
    Default = Divine.AutoAir.enabled,
    Callback = function(value) Divine.AutoAir.enabled = value end
})

air:AddInput('Offset', {
    Default = Divine.AutoAir.jumpOffset,
    Text = 'jump offset',
    Callback = function(value) Divine.AutoAir.jumpOffset = tonumber(value) or 0.8 end
})

air:AddInput('dly', {
    Default = Divine.AutoAir.delay,
    Text = 'Delay',
    Callback = function(value) Divine.AutoAir.delay = tonumber(value) or 0.1 end
})

air:AddDropdown('airpary', {
    Values = {'RightFoot', 'LowerTorso', 'HumanoidRootPart', 'Head', 'UpperTorso'},
    Default = Divine.AutoAir.AirPart,
    Text = 'Auto Air Part',
    Callback = function(value) Divine.AutoAir.AirPart = value end
})

ag:AddToggle('gsEnabled', {
    Text = 'enable',
    Default = getgenv().GroundShotDetection.Enabled,
    Callback = function(value)
        getgenv().GroundShotDetection.Enabled = value
    end
})

ag:AddInput('gsThreshold', {
    Default = '0.5',
    Numeric = true,
    Finished = true,
    Text = 'threshold',
    Callback = function(value)
        getgenv().GroundShotDetection.GroundShotThreshold = tonumber(value) or 5
    end
})

ag:AddInput('gsRange', {
    Default = '20',
    Numeric = true,
    Finished = true,
    Text = 'range',
    Callback = function(value)
        getgenv().GroundShotDetection.DetectionRange = tonumber(value) or 20
    end
})

speed:AddToggle('enablecf', {
    Text = 'Enable CFrame',
    Default = getgenv().cframe.settings.enabled,
    Callback = function(value) getgenv().cframe.settings.enabled = value end
})

speed:AddSlider('cframe_speed', {
    Text = 'CFrame Speed',
    Default = getgenv().cframe.settings.speed or 1,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        getgenv().cframe.settings.speed = value
    end
})

--// REQUIRED SERVICES
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local InputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera

local Crosshair = getgenv().crosshair

local function Solve(angle, radius)
    return Vector2.new(
        math.sin(math.rad(angle)) * radius,
        math.cos(math.rad(angle)) * radius
    )
end

local function GetTorsoPosition(target)
    if target and target.Character and target.Character:FindFirstChild("UpperTorso") then
        local torso = target.Character.UpperTorso
        local pos, onScreen = Camera:WorldToViewportPoint(torso.Position)
        if onScreen then
            return Vector2.new(pos.X, pos.Y)
        end
    end
    return nil
end

local drawings = {
    lines = {},
    outlines = {},
    text1 = Drawing.new("Text"),
    text2 = Drawing.new("Text")
}

drawings.text1.Size = 14
drawings.text1.Font = 2
drawings.text1.Outline = true
drawings.text1.Text = "Eclipse"

drawings.text2.Size = 14
drawings.text2.Font = 2
drawings.text2.Outline = true
drawings.text2.Text = ".lol"

for i = 1, 4 do
    local line = Drawing.new("Line")
    line.Visible = false
    drawings.lines[i] = line

    local outline = Drawing.new("Line")
    outline.Visible = false
    outline.Thickness = 3
    drawings.outlines[i] = outline
end

RunService.RenderStepped:Connect(function()
    if not Crosshair.enabled then
        for i = 1, 4 do
            drawings.lines[i].Visible = false
            drawings.outlines[i].Visible = false
        end
        drawings.text1.Visible = false
        drawings.text2.Visible = false
        return
    end

    local target = getgenv().Divine.Camlock.target
local torsoPos = GetTorsoPosition(target)

local pos =
    (torsoPos) -- if we have a target torso lock to it
    or (Crosshair.mode == "center" and (Camera.ViewportSize / 2))
    or (Crosshair.mode == "mouse" and InputService:GetMouseLocation())
    or Crosshair.position

    drawings.text1.Visible = true
    drawings.text2.Visible = true

    drawings.text1.Color = Crosshair.color
    drawings.text2.Color = Crosshair.color

    local totalWidth = drawings.text1.TextBounds.X + drawings.text2.TextBounds.X

    drawings.text1.Position = pos + Vector2.new(-totalWidth / 2, Crosshair.radius + 18)
    drawings.text2.Position = drawings.text1.Position + Vector2.new(drawings.text1.TextBounds.X, 0)

    for i = 1, 4 do
        local baseAngle = (i - 1) * 90
        local angle = baseAngle
        local length = Crosshair.length

        if Crosshair.spin then
            local t = (tick() * Crosshair.spin_speed) % Crosshair.spin_max
            angle = baseAngle + TweenService:GetValue(t / Crosshair.spin_max, Crosshair.spin_style, Enum.EasingDirection.InOut) * 360
        end

        if Crosshair.resize then
            local pulse = math.sin(tick() * Crosshair.resize_speed) * Crosshair.resize_max
            length = Crosshair.resize_min + math.abs(pulse)
        end

        local from = pos + Solve(angle, Crosshair.radius)
        local to   = pos + Solve(angle, Crosshair.radius + length)

        local outline = drawings.outlines[i]
        outline.From = pos + Solve(angle, Crosshair.radius - 1)
        outline.To   = pos + Solve(angle, Crosshair.radius + length + 1)
        outline.Color = Color3.new(0, 0, 0)
        outline.Visible = true

        local line = drawings.lines[i]
        line.From = from
        line.To = to
        line.Color = Crosshair.color
        line.Thickness = Crosshair.width
        line.Visible = true
    end
end)
local player = game:GetService("Players").LocalPlayer
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local camera = Workspace.CurrentCamera

local lastTrigger = 0

local function isOtherPlayer(part)
    local model = part:FindFirstAncestorOfClass("Model")
    if not model or model == player.Character then return false end

    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end

    local bodyEffects = model:FindFirstChild("BodyEffects")
    local isKnocked = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
    local isGrabbed = model:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
    if isKnocked or isGrabbed then return false end

    if model:FindFirstChildOfClass("ForceField") then return false end

    return Players:GetPlayerFromCharacter(model) ~= nil
end

local function isToolAllowed()
    local character = player.Character
    local backpack = player:FindFirstChildOfClass("Backpack")
    if not character or not backpack then return false end

    for _, item in ipairs(character:GetChildren()) do
        if item:IsA("Tool") and getgenv().triggerbot.BlacklistedTools[item.Name] then
            return false
        end
    end

    for _, item in ipairs(backpack:GetChildren()) do
        if item:IsA("Tool") and getgenv().triggerbot.BlacklistedTools[item.Name] then
            return false
        end
    end

    return true
end

RunService.RenderStepped:Connect(function()
    if not getgenv().triggerbot.Enabled then return end

    local character = player.Character
    if not character or not isToolAllowed() then return end

    local now = tick()
    if now - lastTrigger < getgenv().triggerbot.TriggerCooldown then return end

    local origin = camera.CFrame.Position
    local direction = camera.CFrame.LookVector * 1000

    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local result = Workspace:Raycast(origin, direction, raycastParams)

    if result and result.Instance and isOtherPlayer(result.Instance) then
        lastTrigger = now
        print("Triggerbot Fired!")

        for _, tool in ipairs(character:GetChildren()) do
            if tool:IsA("Tool") then
                tool:Activate()
            end
        end
    end
end)

setup_hooks()

-- SETTINGS TAB UI
local SettingsTab = Tabs.Settings

-- Apply theme manager UI
thememanager:SetLibrary(library)
thememanager:SetFolder("Eclipse")
thememanager:ApplyToTab(SettingsTab)

-- Apply save manager UI
savemanager:SetLibrary(library)
savemanager:SetFolder("Eclipse/configs")
savemanager:SetIgnoreIndexes({"MenuKeybind"})
savemanager:BuildConfigSection(SettingsTab)

-- Auto-load last config
savemanager:LoadAutoloadConfig()


library:Notify("Eclipse loaded successfully", 5)

game.StarterGui:SetCore("SendNotification", {
    Title = "Eclipse",
    Text = "Eclipse successfully loaded",
    Duration = 3
})

task.spawn(function()
    while task.wait() do
        if getgenv().stile.hitbox_expander.Enabled then
            for _, player in pairs(game.Players:GetPlayers()) do
                if player ~= game.Players.LocalPlayer and player.Character then
                    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        pcall(function()
                            local size = getgenv().stile.hitbox_expander.Size
                            hrp.Size = Vector3.new(size, size, size)
                            hrp.Transparency = 1
                            hrp.Color = Color3.new(1,1,1)
                            hrp.Material = Enum.Material.SmoothPlastic
                            hrp.CanCollide = false
                        end)
                    end
                end
            end
        end
    end
end)

local function applySelfChams(char)
    if not getgenv().stile.Visuals.Self.Enabled then return end

    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Material = Enum.Material.Neon
            part.Color = getgenv().stile.Visuals.Self.Color
            part.CanCollide = false
        end
    end
end

local lp = game.Players.LocalPlayer

lp.CharacterAdded:Connect(function(char)
    task.wait(0.5)
    applySelfChams(char)
end)

if lp.Character then
    applySelfChams(lp.Character)
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--// MASTER ESP TOGGLE FUNCTION
local function ESPEnabledCheck()
    return ESPSettings.Enabled
end

--// FUNCTIONS
local function CreateText(color, outline)
    local text = Drawing.new("Text")
    text.Size = 13
    text.Center = true
    text.Outline = true
    text.Visible = false
    text.Color = color
    text.OutlineColor = outline
    text.Font = 2
    return text
end

local function CreateLine(thickness, color)
    local line = Drawing.new("Line")
    line.Visible = false
    line.Color = color
    line.Thickness = thickness
    return line
end

local function CreateQuad(thickness, color)
    local quad = Drawing.new("Quad")
    quad.Visible = false
    quad.Color = color
    quad.Thickness = thickness
    quad.Filled = false
    return quad
end

local function GetOrigin()
    local size = Camera.ViewportSize
    if ESPSettings.Tracer.FollowMouse then
        local pos = UserInputService:GetMouseLocation()
        return Vector2.new(pos.X, pos.Y + 36)
    elseif ESPSettings.Tracer.From == "Middle" then
        return size * 0.5
    else
        return Vector2.new(size.X / 2, size.Y)
    end
end

--// MAIN ESP FUNCTION
local function AddESP(player)
    local drawings = {
        Box = CreateQuad(ESPSettings.Box.Thickness, ESPSettings.Box.Color),
        BoxOutline = ESPSettings.Box.UseOutline and CreateQuad(ESPSettings.Box.Thickness + 1, ESPSettings.Box.OutlineColor) or nil,
        Tracer = ESPSettings.Tracer.Enabled and CreateLine(ESPSettings.Tracer.Thickness, ESPSettings.Tracer.Color) or nil,
        TracerOutline = ESPSettings.Tracer.UseOutline and CreateLine(ESPSettings.Tracer.Thickness + 1, ESPSettings.Tracer.OutlineColor) or nil,
        Name = ESPSettings.NameTag.Enabled and CreateText(ESPSettings.NameTag.Color, ESPSettings.NameTag.OutlineColor) or nil,
        Distance = ESPSettings.Distance.Enabled and CreateText(ESPSettings.Distance.Color, ESPSettings.Distance.OutlineColor) or nil,
        HealthBG = ESPSettings.HealthBar.Enabled and CreateLine(3, ESPSettings.HealthBar.OutlineColor) or nil,
        Health = ESPSettings.HealthBar.Enabled and CreateLine(1.5, Color3.new(0, 1, 0)) or nil
    }

    local highlight = nil
    if ESPSettings.Highlight.Enabled then
        highlight = Instance.new("Highlight")
        highlight.FillColor = ESPSettings.Highlight.FillColor
        highlight.OutlineColor = ESPSettings.Highlight.OutlineColor
        highlight.FillTransparency = ESPSettings.Highlight.Transparency
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Parent = player.Character or player.CharacterAdded:Wait()
    end

    RunService.RenderStepped:Connect(function()
        --// 🔥 MASTER TOGGLE OFF = FULL ESP HIDDEN
        if not ESPEnabledCheck() then
            for _, obj in pairs(drawings) do
                if obj then obj.Visible = false end
            end
            if highlight then
                highlight.Enabled = false
            end
            return
        end

        local char = player.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") or not char:FindFirstChild("Humanoid") or char.Humanoid.Health <= 0 then
            for _, obj in pairs(drawings) do
                if obj then obj.Visible = false end
            end
            if highlight then
                highlight.Enabled = false
            end
            return
        end

        local hrp = char:FindFirstChild("HumanoidRootPart")
        local head = char:FindFirstChild("Head")
        local pos, visible = Camera:WorldToViewportPoint(hrp.Position)

        if not visible then
            for _, obj in pairs(drawings) do
                if obj then obj.Visible = false end
            end
            if highlight then
                highlight.Enabled = false
            end
            return
        end

        local headPos = Camera:WorldToViewportPoint(head.Position)
        local height = math.clamp((Vector2.new(headPos.X, headPos.Y) - Vector2.new(pos.X, pos.Y)).Magnitude, 2, 300)
        local x, y = pos.X, pos.Y

        -- Box
        local function ApplyQuad(quad, w)
            quad.PointA = Vector2.new(x + w, y - height * 2)
            quad.PointB = Vector2.new(x - w, y - height * 2)
            quad.PointC = Vector2.new(x - w, y + height * 2)
            quad.PointD = Vector2.new(x + w, y + height * 2)
            quad.Visible = true
        end

        if ESPSettings.TeamCheck and player.Team == LocalPlayer.Team then
            if drawings.Box then drawings.Box.Color = ESPSettings.Box.OutlineColor end
        else
            if drawings.Box then drawings.Box.Color = ESPSettings.Box.Color end
        end

        if ESPSettings.Box.Enabled then
            if drawings.Box then ApplyQuad(drawings.Box, height) end
            if drawings.BoxOutline then ApplyQuad(drawings.BoxOutline, height + 1) end
        else
            if drawings.Box then drawings.Box.Visible = false end
            if drawings.BoxOutline then drawings.BoxOutline.Visible = false end
        end

        -- Tracer
        local origin = GetOrigin()
        if ESPSettings.Tracer.Enabled then
            if drawings.Tracer then
                drawings.Tracer.From = origin
                drawings.Tracer.To = Vector2.new(x, y + height * 2)
                drawings.Tracer.Visible = true
            end
            if drawings.TracerOutline then
                drawings.TracerOutline.From = origin
                drawings.TracerOutline.To = Vector2.new(x, y + height * 2)
                drawings.TracerOutline.Visible = true
            end
        else
            if drawings.Tracer then drawings.Tracer.Visible = false end
            if drawings.TracerOutline then drawings.TracerOutline.Visible = false end
        end

        -- Name
        if ESPSettings.NameTag.Enabled and drawings.Name then
            drawings.Name.Text = player.Name
            drawings.Name.Position = Vector2.new(x, y - height * 2 - 14)
            drawings.Name.Visible = true
        elseif drawings.Name then
            drawings.Name.Visible = false
        end

        -- Distance
        if ESPSettings.Distance.Enabled and drawings.Distance then
            local dist = math.floor((Camera.CFrame.Position - hrp.Position).Magnitude)
            drawings.Distance.Text = "[" .. dist .. "m]"
            drawings.Distance.Position = Vector2.new(x, y + height * 2 + 2)
            drawings.Distance.Visible = true
        elseif drawings.Distance then
            drawings.Distance.Visible = false
        end

        -- Health
        if ESPSettings.HealthBar.Enabled and drawings.Health and drawings.HealthBG then
            local percent = char.Humanoid.Health / char.Humanoid.MaxHealth
            local top = Vector2.new(x - height - 5, y - height * 2)
            local bottom = Vector2.new(x - height - 5, y + height * 2)

            drawings.HealthBG.From = bottom
            drawings.HealthBG.To = top
            drawings.HealthBG.Visible = true

            drawings.Health.From = bottom
            drawings.Health.To = bottom:Lerp(top, percent)
            drawings.Health.Color = Color3.new(1 - percent, percent, 0)
            drawings.Health.Visible = true
        else
            if drawings.Health then drawings.Health.Visible = false end
            if drawings.HealthBG then drawings.HealthBG.Visible = false end
        end

        if highlight then
            highlight.Enabled = ESPSettings.Highlight.Enabled
            highlight.Adornee = char
        end
    end)
end

--// APPLY ESP TO PLAYERS
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        AddESP(player)
        player.CharacterAdded:Connect(function()
            task.wait(1)
            AddESP(player)
        end)
    end
end

Players.PlayerAdded:Connect(function(plr)
    if plr ~= LocalPlayer then
        plr.CharacterAdded:Connect(function()
            task.wait(1)
            AddESP(plr)
        end)
    end
end)

local Lighting = game:GetService("Lighting")

function ApplyAmbient()
    if not getgenv().DivineAmbient.Enabled then return end

    Lighting.Ambient = getgenv().DivineAmbient.Color
    Lighting.OutdoorAmbient = getgenv().DivineAmbient.Color

    Lighting.EnvironmentDiffuseScale = 1
    Lighting.EnvironmentSpecularScale = 1

    Lighting.Brightness = 2.5
    Lighting.ClockTime = 14
end

function ResetAmbient()
    -- reset to Roblox default
    Lighting.Ambient = Color3.fromRGB(127, 127, 127)
    Lighting.OutdoorAmbient = Color3.fromRGB(127, 127, 127)
end